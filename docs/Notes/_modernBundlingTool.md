# 現代前端 Bundling Tool 及相關工具



## Webpack

---

Webpack 是一個用來實現模組化開發的打包工具，藉由在 webpack.config.js 所寫好的設定來進行編譯打包的動作，將所有模組組合成瀏覽器能解讀的模樣。

在 webpack.config.js 我們可以設定專案的進入點、輸出路徑、引入不同類型模組解析用的 loader、alias path、dev server、打包壓縮規則及 split chunk 等等的優化設定。

> 其他可設定項目
>
> - 在載入 JS 的時候順便做 uglify
> - 在載入 CSS 的時候順便做 minify 
> - 把打包出來的檔名順便加上 hash 
> - 根據不同頁面打包不同的檔案，就不用一次載入全部 JS 支援動態引入 JS，有需要的時候才載入

通常會使用 webpack 來開發 app，是當我們希望用模組化的方式開發、使用一些瀏覽器可能不原生支援的功能或語法，例如 SCSS/SASS、ES6 一些新語法，透過 webpack 設定打包規則，最終可打包出瀏覽器能運行的程式碼。



## Vite

---

> Webpack 這類的 bundler，會慢的原因，是因為他們需要靜態分析過 app 的所有檔案以及套件的相依性， 然後根據這些資訊把東西包在一起，當你的檔案愈來愈大的時候，花的時間也就自然愈來愈多， 因為 webpack 要搞清楚到底要怎麼打包。
>
> by huli's blog?

Vite的开发服务器（vite dev server）在启动时执行了一系列任务，以支持现代化的前端开发。以下是Vite dev server启动时所执行的主要步骤：

1. **创建服务器实例：** 首先，Vite会创建一个Node.js服务器实例，通常使用Express.js或Koa.js等服务器框架。
2. **解析Vite配置：** Vite会读取项目根目录下的`vite.config.js`文件（如果存在）以及内置的默认配置。这些配置文件包含有关开发服务器的设置，如主机、端口、代理等。
3. **识别入口文件：** Vite会查找项目中的入口文件，通常是`src/main.js`或`src/index.js`。入口文件是应用程序的起点，Vite会从这里开始构建依赖关系图。
4. **创建依赖关系图：** Vite会分析入口文件及其依赖项，构建一个依赖关系图。这个图形表示了所有模块之间的依赖关系，这有助于实现按需加载和模块级别的热更新。
5. **启动开发服务器：** Vite会将静态文件（如HTML、CSS、图片等）提供给浏览器，并启动开发服务器，监听指定的主机和端口以接受请求。
6. **等待请求：** 开发服务器会等待来自浏览器的请求。当浏览器加载页面时，它会请求HTML文件。Vite会动态生成HTML，并将它发送回浏览器。
7. **按需加载：** 当浏览器请求JavaScript、CSS或其他模块时，Vite会根据依赖关系图中的信息动态加载相应的模块。这意味着只有在需要时才会加载模块，而不是预先打包到一个大文件中。
8. **模块热更新：** 如果开发人员对代码进行了更改，Vite会使用模块热更新（HMR）来替换已更改的模块，而无需刷新整个页面。这加速了开发周期。
9. **代理和中间件：** Vite支持代理配置和中间件，允许开发人员处理跨域请求、自定义路由、添加身份验证等。
10. **日志和错误处理：** Vite会在控制台输出有关构建和请求的日志信息，并提供有关错误的详细信息，以便开发人员调试问题。

---

1. 直接使用 ESM ，不去作 bundling 把所有東西包在一起，因此少了轉換翻譯的時間

2. 啟動 dev server 就是直接啟動，當訪問到特定 route 才去打包、下載相對應的資料

   -> 只有目前瀏覽頁面有用到的 module 才會被載入、更新 （所以瀏覽器一定要支援 dynamic import)

3. production 使用 rollup (bundler tool) 打包，走傳統的打包策略，跟 webpack 是一樣的

   因為 native import module 會產生「依賴鏈」，在 production 情況下會產生 waterfall request，要下載完所有依賴才能開始功能，效能不理想 （dev 情況下沒問題是因為資源都在本機，下載幾乎是瞬間就好了）

---

Vite v.s. webpack

|                              | Webpack                                                      | Vite                                                         |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Dev. server 原理             | 由 app 進入點解析、打包所有資源，啟動一個 Node.js 後端來 serve 這些輸出的 bundles，並利用 webSocket 來實現即時程式碼更新 | 啟動一個 Node.js 後端，載入第一個畫面會需要用到的所有資源，路由改變後，動態下載需要的資源，並利用 webSocket 來實現即時程式碼更新 |
| HMR (Hot Module Replacement) | 需要額外安裝並設置插件來啟用                                 | 開箱即用                                                     |
| Dev. server 啟動速度         | 較慢，因為需要時間去解析 app 所有檔案及套件的相依性，並打包在一起。隨著 app 變大，所花時間會越長。 | 較快，利用瀏覽器原生支援 ESM，不再需要將所有東西都包在一起，減少了轉換翻譯的時間 |
| Production                   | bundling                                                     | Rollup bundling                                              |
|                              |                                                              | 用 Go 編寫的 ESbuild 取代 JS 編寫的 build tool，加快依賴的 building time<br />常更動的 JSX、CSS 等等程式碼，仰賴原生 ESM ，以基於路由的方式動態引入需要的原始碼，來加快 dev server 啟動速度 |
